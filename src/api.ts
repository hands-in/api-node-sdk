/* tslint:disable */
/* eslint-disable */
/**
 * Merchant API
 * The Hands In API is the first and only service that enables users to transact within a group. Our API is heavily orientated around being a RESTful service  that has predictable resource-oriented URLs, accepts form-encoded request bodies, returns JSON-encoded responses, ant utilizes standard HTTP response codes
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export enum AVSStatus {
    ACCEPTED = 'AVS_ACCEPTED',
    REJECTED = 'AVS_REJECTED',
    NOT_CHECKED = 'AVS_NOT_CHECKED'
}


/**
 * 
 * @export
 * @interface AccountApp
 */
export interface AccountApp {
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'accId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'appId': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'appName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountApp
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface AccountCreationParams
 */
export interface AccountCreationParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof AccountCreationParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof AccountCreationParams
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountCreationParams
     */
    'lastName'?: string;
    /**
     * 
     * @type {Language}
     * @memberof AccountCreationParams
     */
    'language'?: Language;
    /**
     * 
     * @type {Country}
     * @memberof AccountCreationParams
     */
    'country'?: Country;
}
/**
 * 
 * @export
 * @interface AccountDTO
 */
export interface AccountDTO {
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountDTO
     */
    'emailVerified': boolean;
    /**
     * 
     * @type {Country}
     * @memberof AccountDTO
     */
    'country'?: Country;
    /**
     * 
     * @type {Language}
     * @memberof AccountDTO
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountDTO
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {AddressLines}
     * @memberof Address
     */
    'addressLines': AddressLines;
    /**
     * The recipient\'s/contacts name at this address
     * @type {string}
     * @memberof Address
     */
    'name'?: string;
    /**
     * The city/state the address is in
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country': Country;
    /**
     * The unique post code (also known as a zip code) to an address
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
    /**
     * The organization/company name at this address (if there is one)
     * @type {string}
     * @memberof Address
     */
    'organization'?: string;
    /**
     * This property contains additional information, such as the name of the neighborhood or landmark associated with the area. It might also refer to a common name thatâ€™s associated with the location
     * @type {string}
     * @memberof Address
     */
    'sublocality'?: string;
}
/**
 * The address
 * @export
 * @interface AddressLines
 */
export interface AddressLines {
    /**
     * The primary address information including the street address and house/flat number.
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine1': string;
    /**
     * This address line is the locality (i.e. a subsection of a town)
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine2'?: string;
    /**
     * This address line is the area name (i.e. a town or state)
     * @type {string}
     * @memberof AddressLines
     */
    'addressLine3'?: string;
}
/**
 * 
 * @export
 * @interface AllocatedItem
 */
export interface AllocatedItem {
    /**
     * 
     * @type {string}
     * @memberof AllocatedItem
     */
    'itemId': string;
    /**
     * 
     * @type {Money}
     * @memberof AllocatedItem
     */
    'amountMoney': Money;
    /**
     * 
     * @type {number}
     * @memberof AllocatedItem
     */
    'quantity': number;
}
/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CVVStatus {
    ACCEPTED = 'CVV_ACCEPTED',
    REJECTED = 'CVV_REJECTED',
    NOT_CHECKED = 'CVV_NOT_CHECKED'
}


/**
 * 
 * @export
 * @enum {string}
 */

export enum CardBrand {
    OTHER_BRAND = 'OTHER_BRAND',
    VISA = 'VISA',
    MASTERCARD = 'MASTERCARD',
    AMERICAN_EXPRESS = 'AMERICAN_EXPRESS',
    DISCOVER = 'DISCOVER',
    DISCOVER_DINERS = 'DISCOVER_DINERS',
    JCB = 'JCB',
    CHINA_UNIONPAY = 'CHINA_UNIONPAY',
    SQUARE_GIFT_CARD = 'SQUARE_GIFT_CARD',
    SQUARE_CAPITAL_CARD = 'SQUARE_CAPITAL_CARD',
    INTERAC = 'INTERAC',
    EFTPOS = 'EFTPOS',
    FELICA = 'FELICA',
    EBT = 'EBT'
}


/**
 * 
 * @export
 * @interface CardDetails
 */
export interface CardDetails {
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'id': string;
    /**
     * 
     * @type {CardBrand}
     * @memberof CardDetails
     */
    'cardBrand': CardBrand;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'last4'?: string;
    /**
     * 
     * @type {number}
     * @memberof CardDetails
     */
    'expMonth'?: number;
    /**
     * 
     * @type {number}
     * @memberof CardDetails
     */
    'expYear'?: number;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'cardholderName'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CardDetails
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'customerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'referenceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CardDetails
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'cardType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'prepaidType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardDetails
     */
    'bin'?: string;
}
/**
 * 
 * @export
 * @interface CardPaymentDetails
 */
export interface CardPaymentDetails {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'status'?: string;
    /**
     * 
     * @type {CardDetails}
     * @memberof CardPaymentDetails
     */
    'card'?: CardDetails;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'entryMethod'?: string;
    /**
     * 
     * @type {CVVStatus}
     * @memberof CardPaymentDetails
     */
    'cvvStatus'?: CVVStatus;
    /**
     * 
     * @type {AVSStatus}
     * @memberof CardPaymentDetails
     */
    'avsStatus'?: AVSStatus;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'authResultCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'applicationCryptogram'?: string;
    /**
     * 
     * @type {CardVerificationMethod}
     * @memberof CardPaymentDetails
     */
    'verificationMethod'?: CardVerificationMethod;
    /**
     * 
     * @type {CardVerificationResult}
     * @memberof CardPaymentDetails
     */
    'verificationResults'?: CardVerificationResult;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentDetails
     */
    'statementDescription'?: string;
    /**
     * 
     * @type {DeviceDetails}
     * @memberof CardPaymentDetails
     */
    'deviceDetails'?: DeviceDetails;
    /**
     * 
     * @type {CardPaymentTimeline}
     * @memberof CardPaymentDetails
     */
    'cardPaymentTimeline'?: CardPaymentTimeline;
    /**
     * 
     * @type {boolean}
     * @memberof CardPaymentDetails
     */
    'refundRequiresCardPresence'?: boolean;
    /**
     * Information about errors encountered during the request.
     * @type {Array<PaymentError>}
     * @memberof CardPaymentDetails
     */
    'errors'?: Array<PaymentError>;
}
/**
 * 
 * @export
 * @interface CardPaymentTimeline
 */
export interface CardPaymentTimeline {
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'authorizedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'capturedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CardPaymentTimeline
     */
    'voidedAt'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum CardVerificationMethod {
    PIN = 'PIN',
    PIN_AND_SIGNATURE = 'PIN_AND_SIGNATURE',
    SIGNATURE = 'SIGNATURE',
    ON_DEVICE = 'ON_DEVICE',
    NONE = 'NONE'
}


/**
 * 
 * @export
 * @enum {string}
 */

export enum CardVerificationResult {
    SUCCESS = 'SUCCESS',
    FAILURE = 'FAILURE',
    UNKNOWN = 'UNKNOWN'
}


/**
 * 
 * @export
 * @interface Checkout
 */
export interface Checkout {
    /**
     * A unique identifier for the checkout session object.
     * @type {string}
     * @memberof Checkout
     */
    'id': string;
    /**
     * 
     * @type {CheckoutStatus}
     * @memberof Checkout
     */
    'status': CheckoutStatus;
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof Checkout
     */
    'orderId': string;
    /**
     * The date and time at which the checkout session will expire. If undefined the checkout session will expire after 7 days.
     * @type {string}
     * @memberof Checkout
     */
    'expirationDate': string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof Checkout
     */
    'url': string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof Checkout
     */
    'customerId'?: string;
    /**
     * A unique identifier for the payment object.
     * @type {string}
     * @memberof Checkout
     */
    'paymentId'?: string;
    /**
     * A unique identifier for the group payment object.
     * @type {string}
     * @memberof Checkout
     */
    'groupPaymentId'?: string;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof Checkout
     */
    'checkoutPageOptions'?: CheckoutPageOptions;
    /**
     * The date and time when the checkout session was created
     * @type {string}
     * @memberof Checkout
     */
    'createdAt'?: string;
    /**
     * The date and time when the checkout session was last modified/updated
     * @type {string}
     * @memberof Checkout
     */
    'updatedAt'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof Checkout
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Checkout
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CheckoutBatchGetRequest
 */
export interface CheckoutBatchGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof CheckoutBatchGetRequest
     */
    'checkoutIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CheckoutCreateRequest
 */
export interface CheckoutCreateRequest {
    /**
     * A list of items the customer is purchasing.
     * @type {Array<LineItemCreateRequest>}
     * @memberof CheckoutCreateRequest
     */
    'lineItemParams': Array<LineItemCreateRequest>;
    /**
     * 
     * @type {CheckoutCreateRequestCustomer}
     * @memberof CheckoutCreateRequest
     */
    'customer'?: CheckoutCreateRequestCustomer;
    /**
     * The date and time at which the checkout session will expire. If undefined the checkout session will expire after 7 days.
     * @type {string}
     * @memberof CheckoutCreateRequest
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutCreateRequest
     */
    'checkoutPageOptions'?: CheckoutPageOptions;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CheckoutCreateRequest
     */
    'metaData'?: { [key: string]: string; };
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof CheckoutCreateRequest
     */
    'referenceId'?: string;
}
/**
 * Can be either an existing customer identifier or a customer object.  If this is provided, the customerâ€™s email, name, card details, and address will be pre-filled on the Checkout page. If this is undefined, the checkout will create a new customer object based on information provided during the checkout flow.
 * @export
 * @interface CheckoutCreateRequestCustomer
 */
export interface CheckoutCreateRequestCustomer {
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequestCustomer
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequestCustomer
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CheckoutCreateRequestCustomer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequestCustomer
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Language}
     * @memberof CheckoutCreateRequestCustomer
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof CheckoutCreateRequestCustomer
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CheckoutCreateRequestCustomer
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CheckoutPageOptions
 */
export interface CheckoutPageOptions {
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'successUrl'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'cancelUrl'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CheckoutPageOptions
     */
    'expireUrl'?: string;
    /**
     * The payment methods which are available to customers to pay through
     * @type {Array<PaymentMethod>}
     * @memberof CheckoutPageOptions
     * @deprecated
     */
    'paymentMethods'?: Array<PaymentMethod>;
    /**
     * 
     * @type {ColorScheme}
     * @memberof CheckoutPageOptions
     */
    'style'?: ColorScheme;
    /**
     * If true the customer will not be able to change their basket in the checkout
     * @type {boolean}
     * @memberof CheckoutPageOptions
     */
    'disableEditOrders'?: boolean;
}
/**
 * Indicates the state of the checkout session.  PENDING (The checkout session is still in progress) COMPLETED (The checkout session was completed successfully) CANCELLED (The checkout session was cancelled) EXPIRED (The checkout session was not completed by the `expirationDate`, if there is one)
 * @export
 * @enum {string}
 */

export enum CheckoutStatus {
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    EXPIRED = 'EXPIRED',
    CANCELLED = 'CANCELLED'
}


/**
 * 
 * @export
 * @interface CheckoutUpdateRequest
 */
export interface CheckoutUpdateRequest {
    /**
     * 
     * @type {CheckoutPageOptions}
     * @memberof CheckoutUpdateRequest
     */
    'checkoutPageOptions'?: CheckoutPageOptions;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CheckoutUpdateRequest
     */
    'metaData'?: { [key: string]: string; };
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof CheckoutUpdateRequest
     */
    'referenceId'?: string;
}
/**
 * 
 * @export
 * @interface ColorScheme
 */
export interface ColorScheme {
    /**
     * 
     * @type {string}
     * @memberof ColorScheme
     */
    'secondaryColor': string;
    /**
     * 
     * @type {string}
     * @memberof ColorScheme
     */
    'primaryColor': string;
}
/**
 * 
 * @export
 * @interface CompanyContactDetails
 */
export interface CompanyContactDetails {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CompanyContactDetails
     */
    'email': string;
    /**
     * 
     * @type {Address}
     * @memberof CompanyContactDetails
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CompanyContactDetails
     */
    'phoneNumber'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Country {
    AF = 'AF',
    AX = 'AX',
    AL = 'AL',
    DZ = 'DZ',
    AS = 'AS',
    AD = 'AD',
    AO = 'AO',
    AI = 'AI',
    AQ = 'AQ',
    AG = 'AG',
    AR = 'AR',
    AM = 'AM',
    AW = 'AW',
    AU = 'AU',
    AT = 'AT',
    AZ = 'AZ',
    BS = 'BS',
    BH = 'BH',
    BD = 'BD',
    BB = 'BB',
    BY = 'BY',
    BE = 'BE',
    BZ = 'BZ',
    BJ = 'BJ',
    BM = 'BM',
    BT = 'BT',
    BO = 'BO',
    BQ = 'BQ',
    BA = 'BA',
    BW = 'BW',
    BV = 'BV',
    BR = 'BR',
    IO = 'IO',
    BN = 'BN',
    BG = 'BG',
    BF = 'BF',
    BI = 'BI',
    KH = 'KH',
    CM = 'CM',
    CA = 'CA',
    CV = 'CV',
    KY = 'KY',
    CF = 'CF',
    TD = 'TD',
    CL = 'CL',
    CN = 'CN',
    CX = 'CX',
    CC = 'CC',
    CO = 'CO',
    KM = 'KM',
    CG = 'CG',
    CD = 'CD',
    CK = 'CK',
    CR = 'CR',
    CI = 'CI',
    HR = 'HR',
    CU = 'CU',
    CW = 'CW',
    CY = 'CY',
    CZ = 'CZ',
    DK = 'DK',
    DJ = 'DJ',
    DM = 'DM',
    DO = 'DO',
    EC = 'EC',
    EG = 'EG',
    SV = 'SV',
    GQ = 'GQ',
    ER = 'ER',
    EE = 'EE',
    ET = 'ET',
    FK = 'FK',
    FO = 'FO',
    FJ = 'FJ',
    FI = 'FI',
    FR = 'FR',
    GF = 'GF',
    PF = 'PF',
    TF = 'TF',
    GA = 'GA',
    GM = 'GM',
    GE = 'GE',
    DE = 'DE',
    GH = 'GH',
    GI = 'GI',
    GR = 'GR',
    GL = 'GL',
    GD = 'GD',
    GP = 'GP',
    GU = 'GU',
    GT = 'GT',
    GG = 'GG',
    GN = 'GN',
    GW = 'GW',
    GY = 'GY',
    HT = 'HT',
    HM = 'HM',
    VA = 'VA',
    HN = 'HN',
    HK = 'HK',
    HU = 'HU',
    IS = 'IS',
    IN = 'IN',
    ID = 'ID',
    IR = 'IR',
    IQ = 'IQ',
    IE = 'IE',
    IM = 'IM',
    IL = 'IL',
    IT = 'IT',
    JM = 'JM',
    JP = 'JP',
    JE = 'JE',
    JO = 'JO',
    KZ = 'KZ',
    KE = 'KE',
    KI = 'KI',
    KR = 'KR',
    KP = 'KP',
    KW = 'KW',
    KG = 'KG',
    LA = 'LA',
    LV = 'LV',
    LB = 'LB',
    LS = 'LS',
    LR = 'LR',
    LY = 'LY',
    LI = 'LI',
    LT = 'LT',
    LU = 'LU',
    MO = 'MO',
    MK = 'MK',
    MG = 'MG',
    MW = 'MW',
    MY = 'MY',
    MV = 'MV',
    ML = 'ML',
    MT = 'MT',
    MH = 'MH',
    MQ = 'MQ',
    MR = 'MR',
    MU = 'MU',
    YT = 'YT',
    MX = 'MX',
    FM = 'FM',
    MD = 'MD',
    MC = 'MC',
    MN = 'MN',
    ME = 'ME',
    MS = 'MS',
    MA = 'MA',
    MZ = 'MZ',
    MM = 'MM',
    NA = 'NA',
    NR = 'NR',
    NP = 'NP',
    NL = 'NL',
    NC = 'NC',
    NZ = 'NZ',
    NI = 'NI',
    NE = 'NE',
    NG = 'NG',
    NU = 'NU',
    NF = 'NF',
    MP = 'MP',
    FALSE = 'false',
    OM = 'OM',
    PK = 'PK',
    PW = 'PW',
    PS = 'PS',
    PA = 'PA',
    PG = 'PG',
    PY = 'PY',
    PE = 'PE',
    PH = 'PH',
    PN = 'PN',
    PL = 'PL',
    PT = 'PT',
    PR = 'PR',
    QA = 'QA',
    RE = 'RE',
    RO = 'RO',
    RU = 'RU',
    RW = 'RW',
    BL = 'BL',
    SH = 'SH',
    KN = 'KN',
    LC = 'LC',
    MF = 'MF',
    PM = 'PM',
    VC = 'VC',
    WS = 'WS',
    SM = 'SM',
    ST = 'ST',
    SA = 'SA',
    SN = 'SN',
    RS = 'RS',
    SC = 'SC',
    SL = 'SL',
    SG = 'SG',
    SX = 'SX',
    SK = 'SK',
    SI = 'SI',
    SB = 'SB',
    SO = 'SO',
    ZA = 'ZA',
    GS = 'GS',
    SS = 'SS',
    ES = 'ES',
    LK = 'LK',
    SD = 'SD',
    SR = 'SR',
    SJ = 'SJ',
    SZ = 'SZ',
    SE = 'SE',
    CH = 'CH',
    SY = 'SY',
    TW = 'TW',
    TJ = 'TJ',
    TZ = 'TZ',
    TH = 'TH',
    TL = 'TL',
    TG = 'TG',
    TK = 'TK',
    TO = 'TO',
    TT = 'TT',
    TN = 'TN',
    TR = 'TR',
    TM = 'TM',
    TC = 'TC',
    TV = 'TV',
    UG = 'UG',
    UA = 'UA',
    AE = 'AE',
    GB = 'GB',
    US = 'US',
    UM = 'UM',
    UY = 'UY',
    UZ = 'UZ',
    VU = 'VU',
    VE = 'VE',
    VN = 'VN',
    VG = 'VG',
    VI = 'VI',
    WF = 'WF',
    EH = 'EH',
    YE = 'YE',
    ZM = 'ZM',
    ZW = 'ZW'
}


/**
 * 
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'phoneNumber'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateCustomerRequest
     */
    'address'?: Address;
    /**
     * 
     * @type {Language}
     * @memberof CreateCustomerRequest
     */
    'language'?: Language;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CreateCustomerRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateGroupPaymentRequest
 */
export interface CreateGroupPaymentRequest {
    /**
     * This can be any unique identifier. It is required to protect against accidental duplicate calls, which may cause unintended consequences.
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {CreateGroupPaymentRequestCustomer}
     * @memberof CreateGroupPaymentRequest
     */
    'customer': CreateGroupPaymentRequestCustomer;
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'orderId'?: string;
    /**
     * A unique identifier for the checkout session object.
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'checkoutId'?: string;
    /**
     * If group payment splitType is not BY_ITEM this flag is ignored. If the splitType is BY_ITEM then when this flag is true, the order will be fixed for every member that joins. e.g. if there is 1 ticket in the order, and 3 people join the group, the ticket quantity increases to 3, and they will each be allocated a single ticket to pay for
     * @type {boolean}
     * @memberof CreateGroupPaymentRequest
     */
    'fixedPricePerPerson'?: boolean;
    /**
     * 
     * @type {SplitType}
     * @memberof CreateGroupPaymentRequest
     */
    'splitType'?: SplitType;
    /**
     * 
     * @type {number}
     * @memberof CreateGroupPaymentRequest
     */
    'splitAllocation'?: number;
    /**
     * Requires splitType to be CUSTOM. Contains a mapping from customers to their share of the total amount. {customerId -> money}
     * @type {{ [key: string]: Money; }}
     * @memberof CreateGroupPaymentRequest
     * @deprecated
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * Requires splitType to be BY_ITEM. Contains a mapping from customers to the items they have selected  to pay for. {customerId -> items[]}
     * @type {{ [key: string]: Array<AllocatedItem>; }}
     * @memberof CreateGroupPaymentRequest
     */
    'itemAllocation'?: { [key: string]: Array<AllocatedItem>; };
    /**
     * 
     * @type {Money}
     * @memberof CreateGroupPaymentRequest
     */
    'amountMoney': Money;
    /**
     * The date and time at which the group payment will expire. If undefined the group payment will expire after 7 days.
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {Address}
     * @memberof CreateGroupPaymentRequest
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * This field should no longer be used
     * @type {boolean}
     * @memberof CreateGroupPaymentRequest
     * @deprecated
     */
    'createdByMerchant'?: boolean;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof CreateGroupPaymentRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CreateGroupPaymentRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateGroupPaymentRequestCustomer
 */
export interface CreateGroupPaymentRequestCustomer {
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Language}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CreateGroupPaymentRequestCustomer
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreatePaymentRequest
 */
export interface CreatePaymentRequest {
    /**
     * This can be any unique identifier. It is required to protect against accidental duplicate calls, which may cause unintended consequences.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Money}
     * @memberof CreatePaymentRequest
     */
    'amountMoney': Money;
    /**
     * The id/token for the source of the payment. This can be a generated card nonce or the id to a saved customers card.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'paymentToken': string;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof CreatePaymentRequest
     */
    'billingAddress'?: Address;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'userId'?: string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'customerId'?: string;
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'orderId'?: string;
    /**
     * If set to true, this payment will be completed (captured) automatically. If set to false, this payment is held in an approved (authorised) state until either explicitly completed (captured) or canceled (voided)
     * @type {boolean}
     * @memberof CreatePaymentRequest
     */
    'autocomplete'?: boolean;
    /**
     * The date and time at which the payment will expire if autocomplete is set to false. If undefined the payment will attempt complete after 7 days.
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'description'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof CreatePaymentRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CreatePaymentRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Currency {
    AED = 'AED',
    AFN = 'AFN',
    ALL = 'ALL',
    AMD = 'AMD',
    ANG = 'ANG',
    AOA = 'AOA',
    ARS = 'ARS',
    AUD = 'AUD',
    AWG = 'AWG',
    AZN = 'AZN',
    BAM = 'BAM',
    BBD = 'BBD',
    BDT = 'BDT',
    BGN = 'BGN',
    BHD = 'BHD',
    BIF = 'BIF',
    BMD = 'BMD',
    BND = 'BND',
    BOB = 'BOB',
    BRL = 'BRL',
    BSD = 'BSD',
    BTN = 'BTN',
    BWP = 'BWP',
    BYN = 'BYN',
    BZD = 'BZD',
    CAD = 'CAD',
    CDF = 'CDF',
    CHF = 'CHF',
    CLP = 'CLP',
    CNY = 'CNY',
    COP = 'COP',
    CRC = 'CRC',
    CUC = 'CUC',
    CUP = 'CUP',
    CVE = 'CVE',
    CZK = 'CZK',
    DJF = 'DJF',
    DKK = 'DKK',
    DOP = 'DOP',
    DZD = 'DZD',
    EGP = 'EGP',
    ERN = 'ERN',
    ETB = 'ETB',
    EUR = 'EUR',
    FJD = 'FJD',
    FKP = 'FKP',
    GBP = 'GBP',
    GEL = 'GEL',
    GHS = 'GHS',
    GIP = 'GIP',
    GMD = 'GMD',
    GNF = 'GNF',
    GTQ = 'GTQ',
    GYD = 'GYD',
    HKD = 'HKD',
    HNL = 'HNL',
    HRK = 'HRK',
    HTG = 'HTG',
    HUF = 'HUF',
    IDR = 'IDR',
    ILS = 'ILS',
    INR = 'INR',
    IQD = 'IQD',
    IRR = 'IRR',
    ISK = 'ISK',
    JMD = 'JMD',
    JOD = 'JOD',
    JPY = 'JPY',
    KES = 'KES',
    KGS = 'KGS',
    KHR = 'KHR',
    KMF = 'KMF',
    KPW = 'KPW',
    KRW = 'KRW',
    KWD = 'KWD',
    KYD = 'KYD',
    KZT = 'KZT',
    LAK = 'LAK',
    LBP = 'LBP',
    LKR = 'LKR',
    LRD = 'LRD',
    LSL = 'LSL',
    LYD = 'LYD',
    MAD = 'MAD',
    MDL = 'MDL',
    MGA = 'MGA',
    MKD = 'MKD',
    MMK = 'MMK',
    MNT = 'MNT',
    MOP = 'MOP',
    MRU = 'MRU',
    MUR = 'MUR',
    MVR = 'MVR',
    MWK = 'MWK',
    MXN = 'MXN',
    MYR = 'MYR',
    MZN = 'MZN',
    NAD = 'NAD',
    NGN = 'NGN',
    NIO = 'NIO',
    NOK = 'NOK',
    NPR = 'NPR',
    NZD = 'NZD',
    OMR = 'OMR',
    PAB = 'PAB',
    PEN = 'PEN',
    PGK = 'PGK',
    PHP = 'PHP',
    PKR = 'PKR',
    PLN = 'PLN',
    PYG = 'PYG',
    QAR = 'QAR',
    RON = 'RON',
    RSD = 'RSD',
    RUB = 'RUB',
    RWF = 'RWF',
    SAR = 'SAR',
    SBD = 'SBD',
    SCR = 'SCR',
    SDG = 'SDG',
    SEK = 'SEK',
    SGD = 'SGD',
    SHP = 'SHP',
    SLL = 'SLL',
    SOS = 'SOS',
    SRD = 'SRD',
    SSP = 'SSP',
    STN = 'STN',
    SVC = 'SVC',
    SYP = 'SYP',
    SZL = 'SZL',
    THB = 'THB',
    TJS = 'TJS',
    TMT = 'TMT',
    TND = 'TND',
    TOP = 'TOP',
    TRY = 'TRY',
    TTD = 'TTD',
    TWD = 'TWD',
    TZS = 'TZS',
    UAH = 'UAH',
    UGX = 'UGX',
    USD = 'USD',
    UYU = 'UYU',
    UZS = 'UZS',
    VES = 'VES',
    VND = 'VND',
    VUV = 'VUV',
    WST = 'WST',
    XAF = 'XAF',
    XCD = 'XCD',
    XOF = 'XOF',
    XPF = 'XPF',
    YER = 'YER',
    ZAR = 'ZAR',
    ZMW = 'ZMW',
    ZWL = 'ZWL'
}


/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof Customer
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof Customer
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    'phoneNumber'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof Customer
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Customer
     */
    'address'?: Address;
    /**
     * 
     * @type {Language}
     * @memberof Customer
     */
    'language'?: Language;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof Customer
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Customer
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CustomerBatchGetParams
 */
export interface CustomerBatchGetParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomerBatchGetParams
     */
    'customerIds': Array<string>;
}
/**
 * 
 * @export
 * @interface CustomerCreationParams
 */
export interface CustomerCreationParams {
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {Language}
     * @memberof CustomerCreationParams
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof CustomerCreationParams
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof CustomerCreationParams
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DeviceDetails
 */
export interface DeviceDetails {
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceInstallationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceDetails
     */
    'deviceName'?: string;
}
/**
 * 
 * @export
 * @interface ETSITokenResponse
 */
export interface ETSITokenResponse {
    /**
     * 
     * @type {string}
     * @memberof ETSITokenResponse
     */
    'nfv_token'?: string;
}
/**
 * 
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'referenceId': string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'to': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Email
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'html'?: string;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'text'?: string;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof Email
     */
    'attachment'?: Array<Attachment>;
    /**
     * 
     * @type {string}
     * @memberof Email
     */
    'templateName'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    'variables'?: { [key: string]: string; };
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface EmailCreationParams
 */
export interface EmailCreationParams {
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'templateName': string;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'templateVersion'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof EmailCreationParams
     */
    'variables'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'to': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EmailCreationParams
     */
    'subject': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'cc'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EmailCreationParams
     */
    'bcc'?: Array<string>;
    /**
     * 
     * @type {Array<Attachment>}
     * @memberof EmailCreationParams
     */
    'attachment'?: Array<Attachment>;
}
/**
 * 
 * @export
 * @interface FindAndCountResultCheckout
 */
export interface FindAndCountResultCheckout {
    /**
     * 
     * @type {Array<Checkout>}
     * @memberof FindAndCountResultCheckout
     */
    'data': Array<Checkout>;
    /**
     * 
     * @type {number}
     * @memberof FindAndCountResultCheckout
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface FindAndCountResultGroupPaymentRecord
 */
export interface FindAndCountResultGroupPaymentRecord {
    /**
     * 
     * @type {Array<GroupPaymentRecord>}
     * @memberof FindAndCountResultGroupPaymentRecord
     */
    'data': Array<GroupPaymentRecord>;
    /**
     * 
     * @type {number}
     * @memberof FindAndCountResultGroupPaymentRecord
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface GroupPaymentBatchGetParams
 */
export interface GroupPaymentBatchGetParams {
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupPaymentBatchGetParams
     */
    'groupPaymentIds': Array<string>;
}
/**
 * 
 * @export
 * @interface GroupPaymentCancelRequestBody
 */
export interface GroupPaymentCancelRequestBody {
    /**
     * The identifier for the customer who is cancelling a payment
     * @type {string}
     * @memberof GroupPaymentCancelRequestBody
     * @deprecated
     */
    'userId'?: string;
    /**
     * The identifier for the customer who is cancelling a payment
     * @type {string}
     * @memberof GroupPaymentCancelRequestBody
     */
    'customerId'?: string;
}
/**
 * 
 * @export
 * @interface GroupPaymentRecord
 */
export interface GroupPaymentRecord {
    /**
     * A unique identifier for the merchant object
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'merchantId': string;
    /**
     * A unique identifier for the group payment object.
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'id': string;
    /**
     * Unique customer identifier of the customer who will be the admin/owner of the group payment
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'ownerId': string;
    /**
     * 
     * @type {GroupPaymentStatus}
     * @memberof GroupPaymentRecord
     */
    'status': GroupPaymentStatus;
    /**
     * List of unique customer identifiers who have joined the group
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    'memberIds': Array<string>;
    /**
     * This field is no longer supported
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     * @deprecated
     */
    'createdMemberIds'?: Array<string>;
    /**
     * If group payment splitType is not BY_ITEM this flag is ignored. If the splitType is BY_ITEM then when this flag is true, the order will be fixed for every member that joins. e.g. if there is 1 ticket in the order, and 3 people join the group, the ticket quantity increases to 3, and they will each be allocated a single ticket to pay for
     * @type {boolean}
     * @memberof GroupPaymentRecord
     */
    'fixedPricePerPerson'?: boolean;
    /**
     * A mapping between customers and their respective payment records. A mapping will only be present once a customer has paid their share of the group. {customerId -> paymentId}
     * @type {{ [key: string]: string; }}
     * @memberof GroupPaymentRecord
     */
    'memberPayments': { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof GroupPaymentRecord
     */
    'splitAllocation'?: number;
    /**
     * 
     * @type {SplitType}
     * @memberof GroupPaymentRecord
     */
    'splitType': SplitType;
    /**
     * Requires splitType to be CUSTOM. Contains a mapping from customers to their share of the total amount. {customerId -> money}
     * @type {{ [key: string]: Money; }}
     * @memberof GroupPaymentRecord
     * @deprecated
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * Requires splitType to be BY_ITEM. Contains a mapping from customers to the items they have selected  to pay for. {customerId -> items[]}
     * @type {{ [key: string]: Array<AllocatedItem>; }}
     * @memberof GroupPaymentRecord
     */
    'itemAllocation'?: { [key: string]: Array<AllocatedItem>; };
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'orderId'?: string;
    /**
     * A unique identifier for the checkout session object.
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'checkoutId'?: string;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'approvedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof GroupPaymentRecord
     */
    'refundedMoney'?: Money;
    /**
     * A list of processing fees charged by gateways. Note that not all the gateways support this.
     * @type {Array<ProcessingFee>}
     * @memberof GroupPaymentRecord
     * @deprecated
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * List of unique refund record identifiers related to refunds given to members of this group
     * @type {Array<string>}
     * @memberof GroupPaymentRecord
     */
    'refundIds'?: Array<string>;
    /**
     * 
     * @type {Address}
     * @memberof GroupPaymentRecord
     */
    'shippingAddress'?: Address;
    /**
     * The date and time at which the group payment will expire. If undefined the group payment will expire after 7 days.
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'expirationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'note'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof GroupPaymentRecord
     */
    'metaData'?: { [key: string]: string; };
    /**
     * The inviteUrl is only generated when the group payment is fully hosted by hands in
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRecord
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface GroupPaymentRefundRequest
 */
export interface GroupPaymentRefundRequest {
    /**
     * This can be any unique identifier. It is required to protect against accidental duplicate calls, which may cause unintended consequences.
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {string}
     * @memberof GroupPaymentRefundRequest
     */
    'reason'?: string;
}
/**
 * Indicates what state the group payment is in. PENDING (the group payment is still in progress) APPROVED (the total amount to capture has been authorised) COMPLETED (the total amount has been captured) EXPIRED (the total amount of the group was not authorised before the expirationDate, if there is one)
 * @export
 * @enum {string}
 */

export enum GroupPaymentStatus {
    APPROVED = 'APPROVED',
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    CANCELLED = 'CANCELLED',
    EXPIRED = 'EXPIRED'
}


/**
 * 
 * @export
 * @interface IESGTokenResponse
 */
export interface IESGTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof IESGTokenResponse
     */
    'issued_token_type'?: string;
}
/**
 * 
 * @export
 * @interface IETFTokenResponse
 */
export interface IETFTokenResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof IETFTokenResponse
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'ace_profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'rs_cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof IETFTokenResponse
     */
    'cnf'?: string;
}
/**
 * 
 * @export
 * @interface InvitedMembersValue
 */
export interface InvitedMembersValue {
    /**
     * 
     * @type {string}
     * @memberof InvitedMembersValue
     */
    'inviteKey': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InvitedMembersValue
     */
    'scopes': Array<string>;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * A unique identifier for the item object.
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * Name of the product/service being sold. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof Item
     */
    'amountMoney': Money;
    /**
     * The Stock Keeping Unit ([SKU](https://en.wikipedia.org/wiki/Stock_keeping_unit)) number of the product.  Merchants may use this to differentiate products and track inventory with their internal systems.
     * @type {string}
     * @memberof Item
     */
    'sku'?: string;
    /**
     * This stores key-value pairs to help distinguish variants of the same item
     * @type {{ [key: string]: string; }}
     * @memberof Item
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max 10 images per item. Default image is the first in array.
     * @type {Array<string>}
     * @memberof Item
     */
    'imageUrls'?: Array<string>;
    /**
     * A description of the product/service. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof Item
     */
    'description'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof Item
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Item
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ItemBatchGetRequest
 */
export interface ItemBatchGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemBatchGetRequest
     */
    'itemIds': Array<string>;
}
/**
 * 
 * @export
 * @interface ItemCreateRequest
 */
export interface ItemCreateRequest {
    /**
     * Name of the product/service being sold. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof ItemCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof ItemCreateRequest
     */
    'amountMoney': Money;
    /**
     * A description of the product/service. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof ItemCreateRequest
     */
    'description'?: string;
    /**
     * The Stock Keeping Unit ([SKU](https://en.wikipedia.org/wiki/Stock_keeping_unit)) number of the product.  Merchants may use this to differentiate products and track inventory with their internal systems.
     * @type {string}
     * @memberof ItemCreateRequest
     */
    'sku'?: string;
    /**
     * This stores key-value pairs to help distinguish variants of the same item
     * @type {{ [key: string]: string; }}
     * @memberof ItemCreateRequest
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<string>}
     * @memberof ItemCreateRequest
     */
    'imageUrls'?: Array<string>;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof ItemCreateRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof ItemCreateRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ItemUpdateRequest
 */
export interface ItemUpdateRequest {
    /**
     * Name of the product/service being sold. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Money}
     * @memberof ItemUpdateRequest
     */
    'amountMoney'?: Money;
    /**
     * A description of the product/service. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    'description'?: string;
    /**
     * The Stock Keeping Unit ([SKU](https://en.wikipedia.org/wiki/Stock_keeping_unit)) number of the product.  Merchants may use this to differentiate products and track inventory with their internal systems.
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    'sku'?: string;
    /**
     * This stores key-value pairs to help distinguish variants of the same item
     * @type {{ [key: string]: string; }}
     * @memberof ItemUpdateRequest
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<string>}
     * @memberof ItemUpdateRequest
     */
    'imageUrls'?: Array<string>;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof ItemUpdateRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface JoinGroupPaymentRequest
 */
export interface JoinGroupPaymentRequest {
    /**
     * Use customerId instead
     * @type {string}
     * @memberof JoinGroupPaymentRequest
     * @deprecated
     */
    'userId'?: string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof JoinGroupPaymentRequest
     */
    'customerId'?: string;
    /**
     * This field is no longer supported
     * @type {boolean}
     * @memberof JoinGroupPaymentRequest
     * @deprecated
     */
    'joinedByMerchant'?: boolean;
}
/**
 * 
 * @export
 * @interface KickGroupPaymentRequest
 */
export interface KickGroupPaymentRequest {
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    'ownerId': string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof KickGroupPaymentRequest
     */
    'kickId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Language {
    AA = 'aa',
    AB = 'ab',
    AF = 'af',
    AK = 'ak',
    AM = 'am',
    AR = 'ar',
    AS = 'as',
    AW = 'aw',
    AY = 'ay',
    AZ = 'az',
    B1 = 'b1',
    B2 = 'b2',
    BA = 'ba',
    BE = 'be',
    BG = 'bg',
    BH = 'bh',
    BI = 'bi',
    BL = 'bl',
    BN = 'bn',
    BO = 'bo',
    BR = 'br',
    CA = 'ca',
    CB = 'cb',
    CE = 'ce',
    CO = 'co',
    CS = 'cs',
    CY = 'cy',
    DA = 'da',
    DE = 'de',
    DK = 'dk',
    DZ = 'dz',
    EL = 'el',
    EN = 'en',
    EO = 'eo',
    ES = 'es',
    ET = 'et',
    EU = 'eu',
    FA = 'fa',
    FI = 'fi',
    FJ = 'fj',
    FO = 'fo',
    FR = 'fr',
    FY = 'fy',
    GA = 'ga',
    GD = 'gd',
    GL = 'gl',
    GN = 'gn',
    GU = 'gu',
    HA = 'ha',
    HI = 'hi',
    HR = 'hr',
    HT = 'ht',
    HU = 'hu',
    HY = 'hy',
    IA = 'ia',
    IE = 'ie',
    IK = 'ik',
    IN = 'in',
    IS = 'is',
    IT = 'it',
    IW = 'iw',
    JA = 'ja',
    JI = 'ji',
    JW = 'jw',
    KA = 'ka',
    KB = 'kb',
    KI = 'ki',
    KK = 'kk',
    KL = 'kl',
    KM = 'km',
    KN = 'kn',
    KO = 'ko',
    KS = 'ks',
    KU = 'ku',
    KY = 'ky',
    LA = 'la',
    LB = 'lb',
    LM = 'lm',
    LN = 'ln',
    LO = 'lo',
    LT = 'lt',
    LV = 'lv',
    MG = 'mg',
    MI = 'mi',
    MK = 'mk',
    ML = 'ml',
    MN = 'mn',
    MO = 'mo',
    MR = 'mr',
    MS = 'ms',
    MT = 'mt',
    MU = 'mu',
    MW = 'mw',
    MY = 'my',
    NA = 'na',
    NE = 'ne',
    NL = 'nl',
    FALSE = 'false',
    OC = 'oc',
    OM = 'om',
    OR = 'or',
    PA = 'pa',
    PL = 'pl',
    PS = 'ps',
    PT = 'pt',
    QU = 'qu',
    RI = 'ri',
    RM = 'rm',
    RN = 'rn',
    RO = 'ro',
    RU = 'ru',
    RW = 'rw',
    SA = 'sa',
    SD = 'sd',
    SG = 'sg',
    SH = 'sh',
    SI = 'si',
    SK = 'sk',
    SL = 'sl',
    SM = 'sm',
    SN = 'sn',
    SO = 'so',
    SQ = 'sq',
    SR = 'sr',
    SS = 'ss',
    ST = 'st',
    SU = 'su',
    SV = 'sv',
    SW = 'sw',
    TA = 'ta',
    TE = 'te',
    TG = 'tg',
    TH = 'th',
    TI = 'ti',
    TK = 'tk',
    TL = 'tl',
    TM = 'tm',
    TN = 'tn',
    TO = 'to',
    TR = 'tr',
    TS = 'ts',
    TT = 'tt',
    TW = 'tw',
    TZ = 'tz',
    UG = 'ug',
    UK = 'uk',
    UR = 'ur',
    UZ = 'uz',
    VI = 'vi',
    VO = 'vo',
    WO = 'wo',
    XH = 'xh',
    YO = 'yo',
    ZH = 'zh',
    ZU = 'zu'
}


/**
 * 
 * @export
 * @interface LeaveGroupPaymentRequest
 */
export interface LeaveGroupPaymentRequest {
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    'customerId': string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof LeaveGroupPaymentRequest
     */
    'newOwnerId'?: string;
}
/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * 
     * @type {Item}
     * @memberof LineItem
     */
    'item': Item;
    /**
     * 
     * @type {number}
     * @memberof LineItem
     */
    'quantity': number;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    'subtotalAmount': Money;
    /**
     * 
     * @type {Money}
     * @memberof LineItem
     */
    'totalAmount': Money;
}
/**
 * 
 * @export
 * @interface LineItemCreateRequest
 */
export interface LineItemCreateRequest {
    /**
     * 
     * @type {LineItemCreateRequestItem}
     * @memberof LineItemCreateRequest
     */
    'item': LineItemCreateRequestItem;
    /**
     * 
     * @type {number}
     * @memberof LineItemCreateRequest
     */
    'quantity': number;
}
/**
 * Can be either an item identifier or item object.  Note: For dynamic orders (those that can change prices) you must provide an item identifier
 * @export
 * @interface LineItemCreateRequestItem
 */
export interface LineItemCreateRequestItem {
    /**
     * Name of the product/service being sold. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof LineItemCreateRequestItem
     */
    'name': string;
    /**
     * 
     * @type {Money}
     * @memberof LineItemCreateRequestItem
     */
    'amountMoney': Money;
    /**
     * A description of the product/service. This will be displayed to customers on web interfaces.
     * @type {string}
     * @memberof LineItemCreateRequestItem
     */
    'description'?: string;
    /**
     * The Stock Keeping Unit ([SKU](https://en.wikipedia.org/wiki/Stock_keeping_unit)) number of the product.  Merchants may use this to differentiate products and track inventory with their internal systems.
     * @type {string}
     * @memberof LineItemCreateRequestItem
     */
    'sku'?: string;
    /**
     * This stores key-value pairs to help distinguish variants of the same item
     * @type {{ [key: string]: string; }}
     * @memberof LineItemCreateRequestItem
     */
    'attributes'?: { [key: string]: string; };
    /**
     * Max of 10 images per item. The first will always be the default.
     * @type {Array<string>}
     * @memberof LineItemCreateRequestItem
     */
    'imageUrls'?: Array<string>;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof LineItemCreateRequestItem
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof LineItemCreateRequestItem
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface LoginParams
 */
export interface LoginParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof LoginParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof LoginParams
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoginParams
     */
    'scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MembersValue
 */
export interface MembersValue {
    /**
     * 
     * @type {Array<string>}
     * @memberof MembersValue
     */
    'scopes': Array<string>;
}
/**
 * 
 * @export
 * @interface MerchantApiKeySummary
 */
export interface MerchantApiKeySummary {
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'ownerId': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'merchantToken': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantApiKeySummary
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface MerchantDTO
 */
export interface MerchantDTO {
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof MerchantDTO
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {CompanyContactDetails}
     * @memberof MerchantDTO
     */
    'contactDetails': CompanyContactDetails;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    'liveKeys': Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {Array<MerchantApiKeySummary>}
     * @memberof MerchantDTO
     */
    'testKeys': Array<MerchantApiKeySummary>;
    /**
     * 
     * @type {{ [key: string]: MembersValue; }}
     * @memberof MerchantDTO
     */
    'team': { [key: string]: MembersValue; };
    /**
     * 
     * @type {{ [key: string]: InvitedMembersValue; }}
     * @memberof MerchantDTO
     */
    'invites'?: { [key: string]: InvitedMembersValue; };
    /**
     * 
     * @type {Currency}
     * @memberof MerchantDTO
     */
    'defaultCurrency': Currency;
}
/**
 * 
 * @export
 * @interface Money
 */
export interface Money {
    /**
     * 
     * @type {number}
     * @memberof Money
     */
    'amount': number;
    /**
     * 
     * @type {Currency}
     * @memberof Money
     */
    'currency': Currency;
}
/**
 * 
 * @export
 * @interface OAuthTokenResponse
 */
export interface OAuthTokenResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof OAuthTokenResponse
     */
    'scope'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'ace_profile'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'rs_cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'cnf'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'id_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'session_state'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'issued_token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuthTokenResponse
     */
    'nfv_token'?: string;
}
/**
 * 
 * @export
 * @interface OpenIdTokenResponse
 */
export interface OpenIdTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof OpenIdTokenResponse
     */
    'id_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenIdTokenResponse
     */
    'session_state'?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof Order
     */
    'id': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    'status': OrderStatus;
    /**
     * 
     * @type {Array<LineItem>}
     * @memberof Order
     */
    'lineItems': Array<LineItem>;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof Order
     */
    'subtotalMoney': Money;
    /**
     * A unique identifier for the payment object.
     * @type {string}
     * @memberof Order
     */
    'paymentId'?: string;
    /**
     * A unique identifier for the group payment object.
     * @type {string}
     * @memberof Order
     */
    'groupPaymentId'?: string;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    'shippingAddress'?: Address;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof Order
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Order
     */
    'metaData'?: { [key: string]: string; };
    /**
     * The date and time the order was created
     * @type {string}
     * @memberof Order
     */
    'createdAt'?: string;
    /**
     * The date and time the order was last updated/modified
     * @type {string}
     * @memberof Order
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface OrderBatchGetRequest
 */
export interface OrderBatchGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderBatchGetRequest
     */
    'orderIds': Array<string>;
}
/**
 * 
 * @export
 * @interface OrderCreateRequest
 */
export interface OrderCreateRequest {
    /**
     * This is a list of items that will make up the total order
     * @type {Array<LineItemCreateRequest>}
     * @memberof OrderCreateRequest
     */
    'lineItemParams': Array<LineItemCreateRequest>;
    /**
     * 
     * @type {Address}
     * @memberof OrderCreateRequest
     */
    'shippingAddress'?: Address;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof OrderCreateRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof OrderCreateRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * Indicates the state of an order  PENDING (The order is still in progress) COMPLETED (The order will automatically transition to this state when it has been paid for) CANCELLED (The order was cancelled before it was paid for) FULFILLED (The order has been fulfilled/delivered) RETURNED (The order has been returned)
 * @export
 * @enum {string}
 */

export enum OrderStatus {
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    CANCELLED = 'CANCELLED',
    FULFILLED = 'FULFILLED',
    RETURNED = 'RETURNED'
}


/**
 * The order in which objects are returned by
 * @export
 * @enum {string}
 */

export enum OrderType {
    ASCENDING = 'ASCENDING',
    DESCENDING = 'DESCENDING'
}


/**
 * 
 * @export
 * @interface OrderUpdateRequest
 */
export interface OrderUpdateRequest {
    /**
     * This is a list of items that will make up the total order
     * @type {Array<LineItemCreateRequest>}
     * @memberof OrderUpdateRequest
     */
    'lineItemParams': Array<LineItemCreateRequest>;
    /**
     * 
     * @type {Address}
     * @memberof OrderUpdateRequest
     */
    'shippingAddress'?: Address;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof OrderUpdateRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof OrderUpdateRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialConnectRecord
 */
export interface PartialConnectRecord {
    /**
     * 
     * @type {string}
     * @memberof PartialConnectRecord
     */
    'accountId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialConnectRecord
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialConnectRecord
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialConnectRecord
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialConnectRecord
     */
    'expiresAt'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof PartialConnectRecord
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * Make all properties in T optional
 * @export
 * @interface PartialMerchantCreationParams
 */
export interface PartialMerchantCreationParams {
    /**
     * 
     * @type {string}
     * @memberof PartialMerchantCreationParams
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PartialMerchantCreationParams
     */
    'description'?: string;
    /**
     * 
     * @type {CompanyContactDetails}
     * @memberof PartialMerchantCreationParams
     */
    'contactDetails'?: CompanyContactDetails;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof PartialMerchantCreationParams
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof PartialMerchantCreationParams
     */
    'defaultCurrency'?: Currency;
}
/**
 * 
 * @export
 * @interface PasswordResetParams
 */
export interface PasswordResetParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof PasswordResetParams
     */
    'email': string;
    /**
     * Password
     * @type {string}
     * @memberof PasswordResetParams
     */
    'password': string;
    /**
     * Password
     * @type {string}
     * @memberof PasswordResetParams
     */
    'confirmPassword': string;
}
/**
 * 
 * @export
 * @interface PayIntoGroupPaymentRequest
 */
export interface PayIntoGroupPaymentRequest {
    /**
     * This can be any unique identifier. It is required to protect against accidental duplicate calls, which may cause unintended consequences.
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'idempotencyKey': string;
    /**
     * The id/token for the source of the payment. This can be a generated card nonce or the id to a saved customers card.
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'paymentToken': string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'customerId': string;
    /**
     * 
     * @type {Address}
     * @memberof PayIntoGroupPaymentRequest
     */
    'billingAddress'?: Address;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof PayIntoGroupPaymentRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof PayIntoGroupPaymentRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PaymentError
 */
export interface PaymentError {
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentError
     */
    'field'?: string;
}
/**
 * The payment method of which payments will be captured from
 * @export
 * @enum {string}
 */

export enum PaymentMethod {
    CARD = 'CARD',
    OTHER = 'OTHER'
}


/**
 * 
 * @export
 * @interface PaymentRecord
 */
export interface PaymentRecord {
    /**
     * A unique identifier for the payment object.
     * @type {string}
     * @memberof PaymentRecord
     */
    'id': string;
    /**
     * 
     * @type {PaymentStatus}
     * @memberof PaymentRecord
     */
    'status': PaymentStatus;
    /**
     * 
     * @type {PaymentMethod}
     * @memberof PaymentRecord
     */
    'paymentMethod': PaymentMethod;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'totalMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'approvedMoney'?: Money;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRecord
     */
    'refundedMoney'?: Money;
    /**
     * A list of processing fees charged by gateways.  Note: Not all the gateways support this.
     * @type {Array<ProcessingFee>}
     * @memberof PaymentRecord
     * @deprecated
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * List of unique refund record identifiers related to this payment
     * @type {Array<string>}
     * @memberof PaymentRecord
     */
    'refundIds'?: Array<string>;
    /**
     * The date and time at which the payment will expire if autocomplete is set to false. If undefined the payment will attempt complete after 7 days.
     * @type {string}
     * @memberof PaymentRecord
     */
    'expirationDate'?: string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof PaymentRecord
     */
    'customerId'?: string;
    /**
     * A unique identifier for a customer object.
     * @type {string}
     * @memberof PaymentRecord
     */
    'orderId'?: string;
    /**
     * A unique identifier for the group payment object.
     * @type {string}
     * @memberof PaymentRecord
     */
    'groupPaymentId'?: string;
    /**
     * 
     * @type {CardPaymentDetails}
     * @memberof PaymentRecord
     */
    'cardDetails'?: CardPaymentDetails;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {Address}
     * @memberof PaymentRecord
     */
    'billingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentRecord
     */
    'description'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof PaymentRecord
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof PaymentRecord
     */
    'metaData'?: { [key: string]: string; };
    /**
     * If set to true, this payment will be completed (captured) automatically. If set to false, this payment is held in an approved (authorised) state until either explicitly completed (captured) or canceled (voided)
     * @type {boolean}
     * @memberof PaymentRecord
     */
    'autocomplete'?: boolean;
    /**
     * Date and time the payment was created
     * @type {string}
     * @memberof PaymentRecord
     */
    'createdAt': string;
    /**
     * Date and time the payment was last updated/modified
     * @type {string}
     * @memberof PaymentRecord
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface PaymentRefundRequest
 */
export interface PaymentRefundRequest {
    /**
     * This can be any unique identifier. It is required to protect against accidental duplicate calls, which may cause unintended consequences.
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    'idempotencyKey': string;
    /**
     * 
     * @type {Money}
     * @memberof PaymentRefundRequest
     */
    'amountMoney': Money;
    /**
     * 
     * @type {string}
     * @memberof PaymentRefundRequest
     */
    'reason'?: string;
}
/**
 * Indicates the state of the payment  APPROVED (the payment has been authorised) PENDING (the payment is still being processed) COMPLETED (the payment has been captured) FAILED (the payment failed to authorise/capture) CANCELLED (the payment has been voided)
 * @export
 * @enum {string}
 */

export enum PaymentStatus {
    APPROVED = 'APPROVED',
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    CANCELLED = 'CANCELLED',
    FAILED = 'FAILED'
}


/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
 */
export interface PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency {
    /**
     * 
     * @type {string}
     * @memberof PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'description'?: string;
    /**
     * 
     * @type {CompanyContactDetails}
     * @memberof PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'contactDetails': CompanyContactDetails;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof PickMerchantNameOrDescriptionOrContactDetailsOrLogoUrlOrDefaultCurrency
     */
    'defaultCurrency': Currency;
}
/**
 * 
 * @export
 * @interface ProcessingFee
 */
export interface ProcessingFee {
    /**
     * 
     * @type {string}
     * @memberof ProcessingFee
     */
    'type'?: string;
    /**
     * 
     * @type {Money}
     * @memberof ProcessingFee
     */
    'amountMoney': Money;
}
/**
 * 
 * @export
 * @interface RefundRecord
 */
export interface RefundRecord {
    /**
     * A unique identifier for the refund object.
     * @type {string}
     * @memberof RefundRecord
     */
    'id': string;
    /**
     * A unique identifier for the payment object.
     * @type {string}
     * @memberof RefundRecord
     */
    'paymentId': string;
    /**
     * 
     * @type {Money}
     * @memberof RefundRecord
     */
    'amountMoney': Money;
    /**
     * 
     * @type {RefundStatus}
     * @memberof RefundRecord
     */
    'status': RefundStatus;
    /**
     * A list of processing fees charged by gateways.  Note: Not all the gateways support this.
     * @type {Array<ProcessingFee>}
     * @memberof RefundRecord
     * @deprecated
     */
    'processingFees'?: Array<ProcessingFee>;
    /**
     * 
     * @type {string}
     * @memberof RefundRecord
     */
    'reason'?: string;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof RefundRecord
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof RefundRecord
     */
    'metaData'?: { [key: string]: string; };
    /**
     * Date and time the refund was created
     * @type {string}
     * @memberof RefundRecord
     */
    'createdAt'?: string;
    /**
     * Date and time the refund was last updated/modified
     * @type {string}
     * @memberof RefundRecord
     */
    'updatedAt'?: string;
}
/**
 * Indicates the state of the refund  PENDING (The refund is still being processed) COMPLETED (The refund has been processed) REJECTED (The refund was rejected by the merchant) FAILED (The refund failed to go through, e.g. the card network failed to process the refund)
 * @export
 * @enum {string}
 */

export enum RefundStatus {
    PENDING = 'PENDING',
    COMPLETED = 'COMPLETED',
    REJECTED = 'REJECTED',
    FAILED = 'FAILED'
}


/**
 * 
 * @export
 * @interface RequestResetParams
 */
export interface RequestResetParams {
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof RequestResetParams
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'browser'?: string;
    /**
     * 
     * @type {string}
     * @memberof RequestResetParams
     */
    'device'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum Service {
    SQUARE = 'square',
    STRIPE = 'stripe',
    SHUTTLE = 'shuttle'
}


/**
 * 
 * @export
 * @enum {string}
 */

export enum ShuttleEvent {
    PAYMENT_SUCCESS = 'PAYMENT.SUCCESS',
    PAYMENT_FAILED = 'PAYMENT.FAILED',
    PAYMENT_PENDING = 'PAYMENT.PENDING',
    PAYMENT_UPDATE = 'PAYMENT.UPDATE',
    CAPTURE_SUCCESS = 'CAPTURE.SUCCESS',
    CAPTURE_FAILED = 'CAPTURE.FAILED',
    CAPTURE_PENDING = 'CAPTURE.PENDING',
    VOID_SUCCESS = 'VOID.SUCCESS',
    VOID_FAILED = 'VOID.FAILED',
    REFUND_SUCCESS = 'REFUND.SUCCESS',
    REFUND_FAILED = 'REFUND.FAILED',
    REFUND_PENDING = 'REFUND.PENDING',
    CONTRACT_START = 'CONTRACT.START',
    CONTRACT_UPDATE = 'CONTRACT.UPDATE',
    CONTRACT_COMPLETE = 'CONTRACT.COMPLETE',
    CONTRACT_NOTE = 'CONTRACT.NOTE',
    CHARGE_CREATED = 'CHARGE.CREATED',
    CHARGE_UPDATE = 'CHARGE.UPDATE',
    CHARGE_WRITTENOFF = 'CHARGE.WRITTENOFF',
    CHARGE_COMPLETE = 'CHARGE.COMPLETE',
    ACCOUNT_CREATED = 'ACCOUNT.CREATED',
    ACCOUNT_UPDATE = 'ACCOUNT.UPDATE',
    PAYMENT_METHOD_CREATED = 'PAYMENT_METHOD.CREATED',
    PAYMENT_METHOD_UPDATE = 'PAYMENT_METHOD.UPDATE',
    PAYMENT_METHOD_ARCHIVE = 'PAYMENT_METHOD.ARCHIVE',
    GATEWAY_CREATED = 'GATEWAY.CREATED',
    GATEWAY_UPDATE = 'GATEWAY.UPDATE',
    GATEWAY_ARCHIVE = 'GATEWAY.ARCHIVE',
    LEGAL_ENTITY_ROUTE_CREATED = 'LEGAL_ENTITY_ROUTE.CREATED',
    LEGAL_ENTITY_ROUTE_ARCHIVE = 'LEGAL_ENTITY_ROUTE.ARCHIVE',
    INSTANCE_CREATED = 'INSTANCE.CREATED',
    INSTANCE_UPDATE = 'INSTANCE.UPDATE',
    INSTANCE_ARCHIVE = 'INSTANCE.ARCHIVE'
}


/**
 * 
 * @export
 * @interface ShuttleEventRequestBody
 */
export interface ShuttleEventRequestBody {
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'application': string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'instance_key': string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'client': string;
    /**
     * 
     * @type {ShuttleEvent}
     * @memberof ShuttleEventRequestBody
     */
    'action': ShuttleEvent;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'payment'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'capture'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'account'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'payment_method'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'payment_type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShuttleEventRequestBody
     */
    'sandbox'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'refund'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'charge'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'legal_entity_route'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'void'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'deprecated'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShuttleEventRequestBody
     */
    'deprecated_comment'?: string;
}
/**
 * 
 * @export
 * @interface Sms
 */
export interface Sms {
    /**
     * 
     * @type {string}
     * @memberof Sms
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Sms
     */
    'referenceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Sms
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof Sms
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof Sms
     */
    'text'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof Sms
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SmsCreationParams
 */
export interface SmsCreationParams {
    /**
     * 
     * @type {string}
     * @memberof SmsCreationParams
     */
    'to': string;
    /**
     * 
     * @type {string}
     * @memberof SmsCreationParams
     */
    'text': string;
}
/**
 * Indicates what flow the group payment will take. EQUAL (The total amount is split evenly between each member of the group) BY_ITEM (Each member of the group pays for a selection of items) - (requires orderId to be provided) CUSTOM (Each member pays a selected amount of money)
 * @export
 * @enum {string}
 */

export enum SplitType {
    EQUAL = 'EQUAL',
    BY_ITEM = 'BY_ITEM',
    CUSTOM = 'CUSTOM'
}


/**
 * 
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'lastName'?: string;
    /**
     * Email address. See [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322)
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'phoneNumber'?: string;
    /**
     * URL linking to a resource or website.
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {Address}
     * @memberof UpdateCustomerRequest
     */
    'address'?: Address;
    /**
     * 
     * @type {Language}
     * @memberof UpdateCustomerRequest
     */
    'language'?: Language;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof UpdateCustomerRequest
     */
    'metaData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateGroupPaymentRequest
 */
export interface UpdateGroupPaymentRequest {
    /**
     * A unique identifier for the order object.
     * @type {string}
     * @memberof UpdateGroupPaymentRequest
     */
    'orderId'?: string;
    /**
     * A unique identifier for the checkout session object.
     * @type {string}
     * @memberof UpdateGroupPaymentRequest
     */
    'checkoutId'?: string;
    /**
     * If group payment splitType is not BY_ITEM this flag is ignored. If the splitType is BY_ITEM then when this flag is true, the order will be fixed for every member that joins. e.g. if there is 1 ticket in the order, and 3 people join the group, the ticket quantity increases to 3, and they will each be allocated a single ticket to pay for
     * @type {boolean}
     * @memberof UpdateGroupPaymentRequest
     */
    'fixedPricePerPerson'?: boolean;
    /**
     * 
     * @type {SplitType}
     * @memberof UpdateGroupPaymentRequest
     */
    'splitType'?: SplitType;
    /**
     * This field is no longer supported
     * @type {Array<string>}
     * @memberof UpdateGroupPaymentRequest
     * @deprecated
     */
    'createdMemberIds'?: Array<string>;
    /**
     * 
     * @type {Money}
     * @memberof UpdateGroupPaymentRequest
     */
    'amountMoney'?: Money;
    /**
     * 
     * @type {number}
     * @memberof UpdateGroupPaymentRequest
     */
    'splitAllocation'?: number;
    /**
     * Requires splitType to be CUSTOM. Contains a mapping from customers to their share of the total amount. {customerId -> money}
     * @type {{ [key: string]: Money; }}
     * @memberof UpdateGroupPaymentRequest
     * @deprecated
     */
    'customAllocation'?: { [key: string]: Money; };
    /**
     * Requires splitType to be BY_ITEM. Contains a mapping from customers to the items they have selected  to pay for. {customerId -> items[]}
     * @type {{ [key: string]: Array<AllocatedItem>; }}
     * @memberof UpdateGroupPaymentRequest
     */
    'itemAllocation'?: { [key: string]: Array<AllocatedItem>; };
    /**
     * 
     * @type {Address}
     * @memberof UpdateGroupPaymentRequest
     */
    'shippingAddress'?: Address;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupPaymentRequest
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateGroupPaymentRequest
     */
    'statementDescriptionIdentifier'?: string;
    /**
     * This field should no longer be used
     * @type {boolean}
     * @memberof UpdateGroupPaymentRequest
     * @deprecated
     */
    'createdByMerchant'?: boolean;
    /**
     * A unique identifier set by a developer to help reconcile this object with any internal systems
     * @type {string}
     * @memberof UpdateGroupPaymentRequest
     */
    'referenceId'?: string;
    /**
     * A Key-value object to hold additional data
     * @type {{ [key: string]: string; }}
     * @memberof UpdateGroupPaymentRequest
     */
    'metaData'?: { [key: string]: string; };
}

/**
 * CheckoutsApi - axios parameter creator
 * @export
 */
export const CheckoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutCreateRequest} checkoutCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout: async (checkoutCreateRequest: CheckoutCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutCreateRequest' is not null or undefined
            assertParamExists('createCheckout', 'checkoutCreateRequest', checkoutCreateRequest)
            const localVarPath = `/checkouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout: async (checkoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutId' is not null or undefined
            assertParamExists('getCheckout', 'checkoutId', checkoutId)
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/checkouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutUpdateRequest} checkoutUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout: async (checkoutId: string, checkoutUpdateRequest: CheckoutUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutId' is not null or undefined
            assertParamExists('updateCheckout', 'checkoutId', checkoutId)
            // verify required parameter 'checkoutUpdateRequest' is not null or undefined
            assertParamExists('updateCheckout', 'checkoutUpdateRequest', checkoutUpdateRequest)
            const localVarPath = `/checkouts/{checkoutId}`
                .replace(`{${"checkoutId"}}`, encodeURIComponent(String(checkoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutsApi - functional programming interface
 * @export
 */
export const CheckoutsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutCreateRequest} checkoutCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckout(checkoutCreateRequest: CheckoutCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Checkout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckout(checkoutCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheckout(checkoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Checkout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheckout(checkoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCheckouts(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Checkout>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCheckouts(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutUpdateRequest} checkoutUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCheckout(checkoutId: string, checkoutUpdateRequest: CheckoutUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Checkout>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCheckout(checkoutId, checkoutUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CheckoutsApi - factory interface
 * @export
 */
export const CheckoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutsApiFp(configuration)
    return {
        /**
         * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
         * @summary Create a checkout session
         * @param {CheckoutCreateRequest} checkoutCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckout(checkoutCreateRequest: CheckoutCreateRequest, options?: any): AxiosPromise<Checkout> {
            return localVarFp.createCheckout(checkoutCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique dispute ID and receive corresponding checkout details.
         * @summary Retrieve a checkout session
         * @param {string} checkoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckout(checkoutId: string, options?: any): AxiosPromise<Checkout> {
            return localVarFp.getCheckout(checkoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of checkout sessions by supplying the correct parameters.
         * @summary List all checkout sessions
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCheckouts(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<Checkout>> {
            return localVarFp.listCheckouts(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a checkout session by supplying the correct parameters.
         * @summary Update a checkout session
         * @param {string} checkoutId 
         * @param {CheckoutUpdateRequest} checkoutUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckout(checkoutId: string, checkoutUpdateRequest: CheckoutUpdateRequest, options?: any): AxiosPromise<Checkout> {
            return localVarFp.updateCheckout(checkoutId, checkoutUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutsApi - object-oriented interface
 * @export
 * @class CheckoutsApi
 * @extends {BaseAPI}
 */
export class CheckoutsApi extends BaseAPI {
    /**
     * Create a checkout session by supplying the correct parameters. When a customer pays on the checkout session an order will be created.
     * @summary Create a checkout session
     * @param {CheckoutCreateRequest} checkoutCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public createCheckout(checkoutCreateRequest: CheckoutCreateRequest, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).createCheckout(checkoutCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique dispute ID and receive corresponding checkout details.
     * @summary Retrieve a checkout session
     * @param {string} checkoutId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public getCheckout(checkoutId: string, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).getCheckout(checkoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of checkout sessions by supplying the correct parameters.
     * @summary List all checkout sessions
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public listCheckouts(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).listCheckouts(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a checkout session by supplying the correct parameters.
     * @summary Update a checkout session
     * @param {string} checkoutId 
     * @param {CheckoutUpdateRequest} checkoutUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutsApi
     */
    public updateCheckout(checkoutId: string, checkoutUpdateRequest: CheckoutUpdateRequest, options?: AxiosRequestConfig) {
        return CheckoutsApiFp(this.configuration).updateCheckout(checkoutId, checkoutUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CreateCustomerRequest} createCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply a customer identifier to get the corresponding customer object.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (customerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getCustomer', 'customerId', customerId)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find customers that match the provided queries
         * @summary List customers
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (customerId: string, updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateCustomer', 'customerId', customerId)
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CreateCustomerRequest} createCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply a customer identifier to get the corresponding customer object.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(customerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Find customers that match the provided queries
         * @summary List customers
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomers(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomers(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a Customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(customerId, updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Customer
         * @param {CreateCustomerRequest} createCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.deleteCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply a customer identifier to get the corresponding customer object.
         * @summary Retrieve a customer
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(customerId: string, options?: any): AxiosPromise<Customer> {
            return localVarFp.getCustomer(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find customers that match the provided queries
         * @summary List customers
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomers(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<Customer>> {
            return localVarFp.listCustomers(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Customer
         * @param {string} customerId 
         * @param {UpdateCustomerRequest} updateCustomerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<Customer> {
            return localVarFp.updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @summary Create a Customer
     * @param {CreateCustomerRequest} createCustomerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).deleteCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply a customer identifier to get the corresponding customer object.
     * @summary Retrieve a customer
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomer(customerId: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomer(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find customers that match the provided queries
     * @summary List customers
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public listCustomers(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).listCustomers(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Customer
     * @param {string} customerId 
     * @param {UpdateCustomerRequest} updateCustomerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public updateCustomer(customerId: string, updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).updateCustomer(customerId, updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupPaymentsApi - axios parameter creator
 * @export
 */
export const GroupPaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentCancelRequestBody} groupPaymentCancelRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment: async (groupPaymentId: string, groupPaymentCancelRequestBody: GroupPaymentCancelRequestBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('cancelGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'groupPaymentCancelRequestBody' is not null or undefined
            assertParamExists('cancelGroupPayment', 'groupPaymentCancelRequestBody', groupPaymentCancelRequestBody)
            const localVarPath = `/group-payments/{groupPaymentId}/cancel`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPaymentCancelRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment: async (createGroupPaymentRequest: CreateGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroupPaymentRequest' is not null or undefined
            assertParamExists('createGroupPayment', 'createGroupPaymentRequest', createGroupPaymentRequest)
            const localVarPath = `/group-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique group payment ID and receive the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment: async (groupPaymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('getGroupPayment', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds: async (groupPaymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('getGroupPaymentRefunds', 'groupPaymentId', groupPaymentId)
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all group payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/group-payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto: async (groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('payInto', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'payIntoGroupPaymentRequest' is not null or undefined
            assertParamExists('payInto', 'payIntoGroupPaymentRequest', payIntoGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/pay`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payIntoGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment: async (groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('refundGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'groupPaymentRefundRequest' is not null or undefined
            assertParamExists('refundGroupPayment', 'groupPaymentRefundRequest', groupPaymentRefundRequest)
            const localVarPath = `/group-payments/{groupPaymentId}/refunds`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupPaymentRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {UpdateGroupPaymentRequest} updateGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment: async (groupPaymentId: string, updateGroupPaymentRequest: UpdateGroupPaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupPaymentId' is not null or undefined
            assertParamExists('updateGroupPayment', 'groupPaymentId', groupPaymentId)
            // verify required parameter 'updateGroupPaymentRequest' is not null or undefined
            assertParamExists('updateGroupPayment', 'updateGroupPaymentRequest', updateGroupPaymentRequest)
            const localVarPath = `/group-payments/{groupPaymentId}`
                .replace(`{${"groupPaymentId"}}`, encodeURIComponent(String(groupPaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGroupPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupPaymentsApi - functional programming interface
 * @export
 */
export const GroupPaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupPaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentCancelRequestBody} groupPaymentCancelRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelGroupPayment(groupPaymentId: string, groupPaymentCancelRequestBody: GroupPaymentCancelRequestBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelGroupPayment(groupPaymentId, groupPaymentCancelRequestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupPayment(createGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique group payment ID and receive the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPayment(groupPaymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPayment(groupPaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupPaymentRefunds(groupPaymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupPaymentRefunds(groupPaymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all group payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupPaymentRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupPayments(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payInto(groupPaymentId, payIntoGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {UpdateGroupPaymentRequest} updateGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupPayment(groupPaymentId: string, updateGroupPaymentRequest: UpdateGroupPaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupPaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupPayment(groupPaymentId, updateGroupPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupPaymentsApi - factory interface
 * @export
 */
export const GroupPaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupPaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentCancelRequestBody} groupPaymentCancelRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGroupPayment(groupPaymentId: string, groupPaymentCancelRequestBody: GroupPaymentCancelRequestBody, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.cancelGroupPayment(groupPaymentId, groupPaymentCancelRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a group payment
         * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.createGroupPayment(createGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique group payment ID and receive the corresponding group payment.
         * @summary Retrieve a group payment
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPayment(groupPaymentId: string, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.getGroupPayment(groupPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all group payment refunds
         * @param {string} groupPaymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupPaymentRefunds(groupPaymentId: string, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.getGroupPaymentRefunds(groupPaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all group payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<GroupPaymentRecord>> {
            return localVarFp.listGroupPayments(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect a payment from an individual user that is intended to be part of a group payment.
         * @summary Pay into a group payment
         * @param {string} groupPaymentId 
         * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.payInto(groupPaymentId, payIntoGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a full refund back to each customer that paid into the supplied group payment.
         * @summary Refund a group payment
         * @param {string} groupPaymentId 
         * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a group payment
         * @param {string} groupPaymentId 
         * @param {UpdateGroupPaymentRequest} updateGroupPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupPayment(groupPaymentId: string, updateGroupPaymentRequest: UpdateGroupPaymentRequest, options?: any): AxiosPromise<GroupPaymentRecord> {
            return localVarFp.updateGroupPayment(groupPaymentId, updateGroupPaymentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupPaymentsApi - object-oriented interface
 * @export
 * @class GroupPaymentsApi
 * @extends {BaseAPI}
 */
export class GroupPaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a group payment
     * @param {string} groupPaymentId 
     * @param {GroupPaymentCancelRequestBody} groupPaymentCancelRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public cancelGroupPayment(groupPaymentId: string, groupPaymentCancelRequestBody: GroupPaymentCancelRequestBody, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).cancelGroupPayment(groupPaymentId, groupPaymentCancelRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a group payment
     * @param {CreateGroupPaymentRequest} createGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public createGroupPayment(createGroupPaymentRequest: CreateGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).createGroupPayment(createGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique group payment ID and receive the corresponding group payment.
     * @summary Retrieve a group payment
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPayment(groupPaymentId: string, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).getGroupPayment(groupPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all group payment refunds
     * @param {string} groupPaymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public getGroupPaymentRefunds(groupPaymentId: string, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).getGroupPaymentRefunds(groupPaymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all group payments
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public listGroupPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).listGroupPayments(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect a payment from an individual user that is intended to be part of a group payment.
     * @summary Pay into a group payment
     * @param {string} groupPaymentId 
     * @param {PayIntoGroupPaymentRequest} payIntoGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public payInto(groupPaymentId: string, payIntoGroupPaymentRequest: PayIntoGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).payInto(groupPaymentId, payIntoGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a full refund back to each customer that paid into the supplied group payment.
     * @summary Refund a group payment
     * @param {string} groupPaymentId 
     * @param {GroupPaymentRefundRequest} groupPaymentRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public refundGroupPayment(groupPaymentId: string, groupPaymentRefundRequest: GroupPaymentRefundRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).refundGroupPayment(groupPaymentId, groupPaymentRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a group payment
     * @param {string} groupPaymentId 
     * @param {UpdateGroupPaymentRequest} updateGroupPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupPaymentsApi
     */
    public updateGroupPayment(groupPaymentId: string, updateGroupPaymentRequest: UpdateGroupPaymentRequest, options?: AxiosRequestConfig) {
        return GroupPaymentsApiFp(this.configuration).updateGroupPayment(groupPaymentId, updateGroupPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreateRequest} itemCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem: async (itemCreateRequest: ItemCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemCreateRequest' is not null or undefined
            assertParamExists('createItem', 'itemCreateRequest', itemCreateRequest)
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem: async (itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItem', 'itemId', itemId)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateRequest} itemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem: async (itemId: string, itemUpdateRequest: ItemUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('updateItem', 'itemId', itemId)
            // verify required parameter 'itemUpdateRequest' is not null or undefined
            assertParamExists('updateItem', 'itemUpdateRequest', itemUpdateRequest)
            const localVarPath = `/items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreateRequest} itemCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createItem(itemCreateRequest: ItemCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createItem(itemCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItem(itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItem(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItems(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItems(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateRequest} itemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItem(itemId: string, itemUpdateRequest: ItemUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateItem(itemId, itemUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Create an item by supplying the correct parameters.
         * @summary Create an item
         * @param {ItemCreateRequest} itemCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createItem(itemCreateRequest: ItemCreateRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.createItem(itemCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique dispute ID and receive corresponding item details.
         * @summary Retrieve an item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItem(itemId: string, options?: any): AxiosPromise<Item> {
            return localVarFp.getItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of items by supplying the correct parameters.
         * @summary List all items
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItems(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.listItems(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item by supplying the correct parameters.
         * @summary Update an item
         * @param {string} itemId 
         * @param {ItemUpdateRequest} itemUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItem(itemId: string, itemUpdateRequest: ItemUpdateRequest, options?: any): AxiosPromise<Item> {
            return localVarFp.updateItem(itemId, itemUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Create an item by supplying the correct parameters.
     * @summary Create an item
     * @param {ItemCreateRequest} itemCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public createItem(itemCreateRequest: ItemCreateRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).createItem(itemCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique dispute ID and receive corresponding item details.
     * @summary Retrieve an item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItem(itemId: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of items by supplying the correct parameters.
     * @summary List all items
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public listItems(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).listItems(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item by supplying the correct parameters.
     * @summary Update an item
     * @param {string} itemId 
     * @param {ItemUpdateRequest} itemUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public updateItem(itemId: string, itemUpdateRequest: ItemUpdateRequest, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).updateItem(itemId, itemUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an order with line items that can be fulfilled
         * @summary Create an order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (orderCreateRequest: OrderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderCreateRequest' is not null or undefined
            assertParamExists('createOrder', 'orderCreateRequest', orderCreateRequest)
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Orders
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {OrderUpdateRequest} orderUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: string, orderUpdateRequest: OrderUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            // verify required parameter 'orderUpdateRequest' is not null or undefined
            assertParamExists('updateOrder', 'orderUpdateRequest', orderUpdateRequest)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an order with line items that can be fulfilled
         * @summary Create an order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(orderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrder(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Orders
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrders(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrders(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {OrderUpdateRequest} orderUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: string, orderUpdateRequest: OrderUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, orderUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Create an order with line items that can be fulfilled
         * @summary Create an order
         * @param {OrderCreateRequest} orderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(orderCreateRequest: OrderCreateRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.createOrder(orderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId: string, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Orders
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrders(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.listOrders(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an order
         * @param {string} orderId 
         * @param {OrderUpdateRequest} orderUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(orderId: string, orderUpdateRequest: OrderUpdateRequest, options?: any): AxiosPromise<Order> {
            return localVarFp.updateOrder(orderId, orderUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Create an order with line items that can be fulfilled
     * @summary Create an order
     * @param {OrderCreateRequest} orderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(orderCreateRequest: OrderCreateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(orderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrder(orderId: string, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Orders
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public listOrders(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).listOrders(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an order
     * @param {string} orderId 
     * @param {OrderUpdateRequest} orderUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public updateOrder(orderId: string, orderUpdateRequest: OrderUpdateRequest, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updateOrder(orderId, orderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('cancelPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/cancel`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only payments in an APPROVED state can be captured. Doing this will capture the held funds from a customers bank account.
         * @summary Capture an authorised payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('capturePayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/capture`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (createPaymentRequest: CreatePaymentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPaymentRequest' is not null or undefined
            assertParamExists('createPayment', 'createPaymentRequest', createPaymentRequest)
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPayment', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all refunds (partial or full) related to this payment
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds: async (paymentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('getPaymentRefunds', 'paymentId', paymentId)
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startKey !== undefined) {
                localVarQueryParameter['startKey'] = startKey;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a full or partial refund for this payment
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: async (paymentId: string, paymentRefundRequest: PaymentRefundRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('refundPayment', 'paymentId', paymentId)
            // verify required parameter 'paymentRefundRequest' is not null or undefined
            assertParamExists('refundPayment', 'paymentRefundRequest', paymentRefundRequest)
            const localVarPath = `/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelPayment(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPayment(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only payments in an APPROVED state can be captured. Doing this will capture the held funds from a customers bank account.
         * @summary Capture an authorised payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async capturePayment(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.capturePayment(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(createPaymentRequest: CreatePaymentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(createPaymentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all refunds (partial or full) related to this payment
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentRefunds(paymentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentRefunds(paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(startKey, orderBy, orderType, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a full or partial refund for this payment
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundPayment(paymentId, paymentRefundRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(paymentId: string, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.cancelPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Only payments in an APPROVED state can be captured. Doing this will capture the held funds from a customers bank account.
         * @summary Capture an authorised payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment(paymentId: string, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.capturePayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Collect a payment from an individual user
         * @summary Create a payment
         * @param {CreatePaymentRequest} createPaymentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(createPaymentRequest: CreatePaymentRequest, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.createPayment(createPaymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Supply the unique payment ID and receive corresponding payment details.
         * @summary Retrieve a payment
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId: string, options?: any): AxiosPromise<PaymentRecord> {
            return localVarFp.getPayment(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all refunds (partial or full) related to this payment
         * @summary List all payment refunds
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRefunds(paymentId: string, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.getPaymentRefunds(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all payments
         * @param {string} [startKey] 
         * @param {any} [orderBy] 
         * @param {OrderType} [orderType] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: any): AxiosPromise<Array<PaymentRecord>> {
            return localVarFp.listPayments(startKey, orderBy, orderType, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a full or partial refund for this payment
         * @summary Refund a payment
         * @param {string} paymentId 
         * @param {PaymentRefundRequest} paymentRefundRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: any): AxiosPromise<RefundRecord> {
            return localVarFp.refundPayment(paymentId, paymentRefundRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * 
     * @summary Cancel a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public cancelPayment(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).cancelPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only payments in an APPROVED state can be captured. Doing this will capture the held funds from a customers bank account.
     * @summary Capture an authorised payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public capturePayment(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).capturePayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Collect a payment from an individual user
     * @summary Create a payment
     * @param {CreatePaymentRequest} createPaymentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public createPayment(createPaymentRequest: CreatePaymentRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(createPaymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Supply the unique payment ID and receive corresponding payment details.
     * @summary Retrieve a payment
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPayment(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPayment(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all refunds (partial or full) related to this payment
     * @summary List all payment refunds
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPaymentRefunds(paymentId: string, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getPaymentRefunds(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all payments
     * @param {string} [startKey] 
     * @param {any} [orderBy] 
     * @param {OrderType} [orderType] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public listPayments(startKey?: string, orderBy?: any, orderType?: OrderType, pageSize?: number, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).listPayments(startKey, orderBy, orderType, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a full or partial refund for this payment
     * @summary Refund a payment
     * @param {string} paymentId 
     * @param {PaymentRefundRequest} paymentRefundRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public refundPayment(paymentId: string, paymentRefundRequest: PaymentRefundRequest, options?: AxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).refundPayment(paymentId, paymentRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefundsApi - axios parameter creator
 * @export
 */
export const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund: async (refundId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('getRefund', 'refundId', refundId)
            const localVarPath = `/refunds/{refundId}`
                .replace(`{${"refundId"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all refunds
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {OrderType} [orderType] 
         * @param {RefundStatus} [status] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: async (startTime?: string, endTime?: string, orderType?: OrderType, status?: RefundStatus, pageSize?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication merchant-api-key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 * @export
 */
export const RefundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefund(refundId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefund(refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all refunds
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {OrderType} [orderType] 
         * @param {RefundStatus} [status] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefunds(startTime?: string, endTime?: string, orderType?: OrderType, status?: RefundStatus, pageSize?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefunds(startTime, endTime, orderType, status, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefundsApi - factory interface
 * @export
 */
export const RefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a refund
         * @param {string} refundId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefund(refundId: string, options?: any): AxiosPromise<RefundRecord> {
            return localVarFp.getRefund(refundId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all refunds
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {OrderType} [orderType] 
         * @param {RefundStatus} [status] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(startTime?: string, endTime?: string, orderType?: OrderType, status?: RefundStatus, pageSize?: number, options?: any): AxiosPromise<Array<RefundRecord>> {
            return localVarFp.listRefunds(startTime, endTime, orderType, status, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundsApi - object-oriented interface
 * @export
 * @class RefundsApi
 * @extends {BaseAPI}
 */
export class RefundsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a refund
     * @param {string} refundId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public getRefund(refundId: string, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).getRefund(refundId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all refunds
     * @param {string} [startTime] 
     * @param {string} [endTime] 
     * @param {OrderType} [orderType] 
     * @param {RefundStatus} [status] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefundsApi
     */
    public listRefunds(startTime?: string, endTime?: string, orderType?: OrderType, status?: RefundStatus, pageSize?: number, options?: AxiosRequestConfig) {
        return RefundsApiFp(this.configuration).listRefunds(startTime, endTime, orderType, status, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}


